/*
 *    This is a Java program that implements the Quine McClusky Algorithm for Digital Logic Project 1
 *    Author: Trent Haines (tsh160230)
 *    Date: 03/15/2021
 */
import java.util.Collections;
import java.util.*;

public class QuineMc
{
    static int numLits; // number of literals (maximum 10)
    final static char[] alphabet = // characters that form the solution expression (I did not include F because the answer is outputted as F = ...), only up to 10 supported
            {'A', 'B', 'C', 'D', 'E', 'G', 'H', 'I', 'J', 'K'};

    static ArrayList<Integer> minterms; // minterm integer representation
    static ArrayList<Integer> dontcare;

    static ArrayList<String> mintermAndDc; // the minterms and dont cares combined for Quine-McCluskey first stage
    static ArrayList<String> primeImps; // the prime implicants generated by Quine-McCluskey
    static ArrayList<String> binaryOnMinterms; // minterm binary string representation
    static ArrayList<String> binarySolution; // binary form of the final solution
    static ArrayList<String> solution; // set of literal terms for the final solution

    public static void main(String[] args)
    {
        // initialization of class lists
        minterms = new ArrayList<>();
        dontcare = new ArrayList<>();
        mintermAndDc = new ArrayList<>();
        primeImps = new ArrayList<>();
        binaryOnMinterms = new ArrayList<>();
        binarySolution = new ArrayList<>();
        solution = new ArrayList<>();

        // read and parse the input line
        Scanner myScanner = new Scanner(System.in);
        String input = myScanner.nextLine();
        myScanner.close();
        int firstSpace = input.indexOf(" ");
        numLits = Integer.parseInt(input.substring(0, firstSpace)); // first number to be inputted is the number of literals

        if(numLits > 10 || numLits < 1) {
            System.out.println("Please enter a valid number of literals");
            System.exit(1);
        }
        input = input.substring(firstSpace + 1); // get rid of the first number to make parsing easier
        String[] mintermsString;
        String[] dontcareString;
        if(input.indexOf("d") != -1) // if we have dont cares, parse into two separate lists
        {
            String[] arrs = input.split("[ ][d][ ]", 2);
            mintermsString = arrs[0].split(" ");
            dontcareString = arrs[1].split(" ");
            for (String x : dontcareString)
            {
                dontcare.add(Integer.parseInt(x));
            }
        }
        else // otherwise, simply split the input by spaces
        {
            mintermsString = input.split(" ");
        }
        for (String x : mintermsString)
        {
            minterms.add(Integer.parseInt(x));
        }

        for (int i = 0; i < minterms.size(); i++) // add the parsed terms to their lists
        {
            binaryOnMinterms.add(padder(Integer.toBinaryString(minterms.get(i))));
            mintermAndDc.add(padder(Integer.toBinaryString(minterms.get(i))));
        }
        for (int i = 0; i < dontcare.size(); i++) // add the parsed terms to the combined list
        {
            mintermAndDc.add(padder(Integer.toBinaryString(dontcare.get(i))));
        }

        // generate the prime implicants using the expansion with QM
        fillPrimeImps(mintermAndDc);

        // create and extract the optimal cover among Prime Implicants
        boolean[][] cover = createCover();
        extractCover(cover);

        // turn the solution into a set of strings and sort them
        minStringToSolution(binarySolution);
        Collections.sort(solution);

        // format and output the solution into a logical expression
        String ans = "F = ";
        for(int i = 0; i < solution.size(); i++)
        {
            ans+= (solution.get(i) + " + ");
        }
        System.out.println(ans.substring(0,ans.length()-3));
    }


    static String padder(String input) // add 0's to the front of binary string expressions that are too small
    {
        int padlen = numLits - input.length();
        String pad = "";
        for (int i = 0; i < padlen; i++)
        {
            pad += "0";
        }
        return pad+input;
    }


    static String combineString(String term1, String term2) // combines two implicant strings that differ by only one place and have all of the same '-', expands an implicant.
    {
        String combined = "";
        for (int i = 0; i < term1.length(); i++)
        {
            char x = term1.charAt(i);
            if (x != term2.charAt(i))
            {
                combined += "-"; // if we have a 0 and a 1 or a 1 and a 0, combine that into the generalized form of -.
            }
            else
            {
                combined += x; // if we have the same binary number in both strings, copy it over to the combined version
            }
        }
        return combined;
    }


    static boolean isOneDifferent(String term1, String term2) // check if two terms are eligible to be combined into a larger implicant
    {
        int numCharsDiff = 0;
        for (int i = 0; i < term1.length(); i++)
        {
            if (term1.charAt(i) != term2.charAt(i))
                numCharsDiff++;
            if(numCharsDiff > 1)
                return false;
        }
        if(numCharsDiff == 0)
            return false;
        return true; // returns true when one character/literal is different
    }


    static void fillPrimeImps(List<String> binaryTerms)
    {
        ArrayList<String> nextTerms = new ArrayList<>();
        boolean[] wasCombined = new boolean[binaryTerms.size()];
        boolean hasMorePairs = false;

        for (int i = 0; i < binaryTerms.size(); i++)
        {
            for (int j = i+1; j < binaryTerms.size(); j++)
            {
                if (isOneDifferent(binaryTerms.get(i), binaryTerms.get(j)))
                {
                    nextTerms.add(combineString(binaryTerms.get(i), binaryTerms.get(j))); // add the combined term to be used in the next set
                    wasCombined[i] = true; // mark the first term as used
                    wasCombined[j] = true; // mark the second term as used
                    hasMorePairs = true; // indicate that a combination was made during the step, and thus we have possibly not yet exhausted all combinations
                }
            }
        }

        for (int i = 0; i < wasCombined.length; i++)
        {
            if (!primeImps.contains(binaryTerms.get(i)) && !wasCombined[i])
            {
                primeImps.add(binaryTerms.get(i)); // add the unique leftover implicants that were not during combination steps
            }
        }

        if(hasMorePairs) // if we have made a combination, there could be more, so check the next iteration
        {
            fillPrimeImps(nextTerms);
        }
        else
        {
            return;
        }
    }


    static boolean implicantContains(String pImp, String binaryMinterm) // check if a given implicant contains a minterm
    {
        for (int i = 0; i < pImp.length(); i++)
        {
            if (pImp.charAt(i) != '-' && pImp.charAt(i) != binaryMinterm.charAt(i))
            {
                return false;
            }
        }
        return true;
    }


    static boolean[][] createCover() // create a cover containing the marks for which implicants satisfy which minterms
    {
        boolean[][] cover = new boolean[primeImps.size()][binaryOnMinterms.size()];
        int m = cover[0].length;
        for (int i = 0; i < cover.length; i++)
        {
            for (int j = 0; j < m; j++)
            {
                cover[i][j] = implicantContains(primeImps.get(i), binaryOnMinterms.get(j));
            }
        }
        return cover;
    }


    static void minStringToSolution(List<String> minStrs) // construct a solution string set using literals from the binary code
    {
        String term = "";
        for(String x : minStrs)
        {
            for(int i = 0; i< x.length(); i++) // process the binary implicants into literals
            {
                if(x.charAt(i) == '0')
                {
                    term += (alphabet[i] + "'"); // add the corresponding literal, for off bits, we represent this with a ' symbol
                }
                else if(x.charAt(i) == '1')
                {
                    term += (alphabet[i]); // add the corresponding literal
                }
            }
            solution.add(term);
            term = "";
        }
    }


    static void extractCover(boolean[][] cover) // find the best selection from the PI's 
    {
        int trueCount;
        int firstIdx;
        boolean[][] nextCover;

        for(int i = 0; i < cover[0].length; i++) // search and extract EPIs
        {
            trueCount = 0;
            firstIdx = 0;
            for(int j = 0; j < cover.length; j++) // for each entry in a column, count the number of trues
            {
                if(cover[j][i])
                {
                    trueCount++;
                    if(trueCount == 1)
                        firstIdx = j;
                }
            }
            if (trueCount == 1) // if there is only one true entry in a column, it belongs to an EPI at the stored index firstIdx
            {
                //System.out.println("\nadded EPI " + primeImps.get(firstIdx));
                binarySolution.add(primeImps.get(firstIdx));
                for(int k = binaryOnMinterms.size()-1; k >= 0; k--)
                {
                    if(cover[firstIdx][k])
                    {
                        binaryOnMinterms.remove(k); // remove the columns covered by the EPI
                    }
                }
                primeImps.remove(firstIdx); // remove the EPI
                if(primeImps.size() == 0 || binaryOnMinterms.size() == 0) // check if the cover is done
                    return;
                nextCover = createCover();
                extractCover(nextCover); // re-run extraction on the smaller cover
                return;
            }
        }

        ArrayList<Integer> removeIdx = new ArrayList<>(); // if there are no EPIs, look for and remove less-thans
        for(int r1 = 0; r1 < cover.length-1; r1++)
        {
            for(int r2 = r1+1; r2 <cover.length; r2++)
            {
                boolean equals = false;
                boolean lessorequal = true;
                boolean moreorequal = true;
                for(int l = 0; l < cover[0].length; l++) // look through each unique pair of rows
                {
                    if(cover[r1][l] && !cover[r2][l]) // a less than cannot have a true entry where its larger set is false
                    {
                        lessorequal = false;
                    }
                    if(!cover[r1][l] && cover[r2][l]) // a larger set cannot have a false value in the same spot where its less than has a true
                    {
                        moreorequal = false;
                    }
                }
                if(lessorequal && moreorequal)
                    equals = true;

                if(equals)
                {
                    removeIdx.add(new Integer(r1)); // if identical rows, add to list to arbitrarily remove the first prime implicant
                }
                else if(lessorequal)
                {
                    removeIdx.add(new Integer(r1)); // add to list to remove less-than
                }
                else if(moreorequal)
                {
                    removeIdx.add(new Integer(r2)); // add to list to remove less-than
                }
            }
        }
        Collections.sort(removeIdx, Collections.reverseOrder()); // makes indexing with removal easier
        int lastNum = -1;
        for(int p = 0; p < removeIdx.size(); p++)
        {
            if(lastNum != removeIdx.get(p).intValue()) // dont remove duplicates
            {
                primeImps.remove(removeIdx.get(p).intValue()); // remove the less than
            }
            lastNum = removeIdx.get(p).intValue();
        }

        if(removeIdx.size() == 0) // if there are no EPIs or less-thans, extract a remaining prime implicant with the largest cover
        {
            int mostCoveredTrues = 0;
            int mostCoveredRowIdx = 0;
            int trueInRow = 0;
            int q = 0;
            for(boolean[] x: cover) // search through all prime implicants for one with the largest cover
            {
                for(boolean y: x)
                {
                    if(y)
                        trueInRow++; // count the number of trues in each row
                }
                if(trueInRow > mostCoveredTrues) // update the maximum number of trues
                {
                    mostCoveredTrues = trueInRow;
                    mostCoveredRowIdx = q; // save the index of the large prime implicant cover
                }
                trueInRow = 0;
                q++;
            }
            //System.out.println("\nadded PI " + primeImps.get(mostCoveredRowIdx));
            binarySolution.add(primeImps.get(mostCoveredRowIdx));
            for(int k = binaryOnMinterms.size()-1; k >= 0; k--)
            {
                if(cover[mostCoveredRowIdx][k])
                {
                    binaryOnMinterms.remove(k); // remove all of its covered minterm columns
                }
            }
            primeImps.remove(mostCoveredRowIdx); // remove the actual prime implicant
            if(primeImps.size() == 0 || binaryOnMinterms.size() == 0) // check if the cover is finished
                return;
        }
        nextCover = createCover();
        extractCover(nextCover); // re-run the extraction on the smaller cover
        return;
    }
}